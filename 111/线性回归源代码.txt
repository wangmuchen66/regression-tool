<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>一元线性回归工具</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    body {
      background: #111;
      color: white;
      font-family: Arial, sans-serif;
      padding: 5vw;
      line-height: 1.6;
    }
    h1 {
      font-size: 6vw;
      margin-bottom: 4vw;
      color: #4ade80;
      text-align: center;
    }
    h2 {
      font-size: 4.5vw;
      margin: 3vw 0;
    }
    label {
      display: block;
      font-size: 3.8vw;
      margin-bottom: 1.5vw;
      color: #e0e0e0;
    }
    input, textarea {
      width: 100%;
      max-width: 100%;
      padding: 3vw;
      margin-bottom: 3vw;
      border-radius: 8px;
      border: none;
      background: #222;
      color: #fff;
      font-size: 3.5vw;
      resize: vertical;
      min-height: 12vw;
    }
    button {
      width: 100%;
      padding: 3vw;
      border: none;
      border-radius: 10px;
      background: #4ade80;
      color: #000;
      font-size: 4vw;
      cursor: pointer;
      margin: 4vw 0;
      font-weight: bold;
      transition: background 0.2s;
    }
    button:hover {
      background: #34d370;
    }
    #result {
      margin: 4vw 0;
      font-size: 3.5vw;
    }
    .variance-info {
      background: #222;
      padding: 3vw;
      border-radius: 8px;
      margin: 3vw 0;
      font-size: 3.5vw;
    }
    .variance-info p {
      margin: 1.5vw 0;
    }
    canvas {
      background: #222;
      border-radius: 12px;
      margin: 4vw 0;
      width: 100% !important;
      height: auto !important;
      max-width: 600px;
      display: block;
      margin-left: auto;
      margin-right: auto;
    }
    .error {
      color: #ff4d4d;
      font-weight: bold;
    }
    .highlight {
      color: #4ade80;
      font-weight: bold;
    }

    /* 平板/桌面端适配 */
    @media (min-width: 768px) {
      body {
        padding: 2vw;
        max-width: 800px;
        margin: 0 auto;
      }
      h1 {
        font-size: 2.5vw;
      }
      h2 {
        font-size: 2vw;
      }
      label, input, textarea, button, #result, .variance-info {
        font-size: 1.2vw;
      }
      input, textarea {
        padding: 1vw;
        min-height: 60px;
        margin-bottom: 1.5vw;
      }
      button {
        padding: 1.2vw;
        font-size: 1.4vw;
        margin: 2vw 0;
      }
    }
  </style>
</head>
<body>
  <h1>一元线性回归工具</h1>

  <label>输入 X（逗号分隔）</label>
  <textarea id="xValues" placeholder="例如：1, 2, 3, 4"></textarea>

  <label>输入 Y（逗号分隔）</label>
  <textarea id="yValues" placeholder="例如：2, 4, 6, 8"></textarea>

  <button onclick="computeRegression()">计算回归</button>

  <div id="result"></div>

  <canvas id="chart"></canvas>

  <script>
    // 解析输入数组
    function parseArray(str) {
      return str
        .split(',')
        .map(s => parseFloat(s.trim()))
        .filter(v => !isNaN(v));
    }

    // 计算回归及方差分析
    function computeRegression() {
      const xs = parseArray(document.getElementById("xValues").value);
      const ys = parseArray(document.getElementById("yValues").value);
      const resultDiv = document.getElementById("result");
      const canvas = document.getElementById("chart");

      // 基础数据校验
      if (xs.length !== ys.length || xs.length < 2) {
        resultDiv.innerHTML = '<p class="error">请输入长度一致且不少于2个的有效x与y数据！</p>';
        // 清空画布
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        return;
      }

      const n = xs.length;
      // 基础求和计算
      const sumX = xs.reduce((a, b) => a + b, 0);
      const sumY = ys.reduce((a, b) => a + b, 0);
      const sumXY = xs.reduce((a, b, i) => a + b * ys[i], 0);
      const sumXX = xs.reduce((a, b) => a + b * b, 0);
      const meanY = sumY / n; // y的均值

      // 计算斜率和截距
      const denominator = n * sumXX - sumX * sumX;
      if (denominator === 0) {
        resultDiv.innerHTML = '<p class="error">X值全部相同，无法进行线性回归分析！</p>';
        return;
      }
      const slope = (n * sumXY - sumX * sumY) / denominator;
      const intercept = (sumY - slope * sumX) / n;

      // 计算预测值
      const yPred = xs.map(x => slope * x + intercept);

      // 方差分析计算
      // 总平方和 SST = Σ(yi - ȳ)²
      const SST = ys.reduce((sum, y) => sum + Math.pow(y - meanY, 2), 0);
      // 回归平方和 SSR = Σ(ŷi - ȳ)²
      const SSR = yPred.reduce((sum, yp) => sum + Math.pow(yp - meanY, 2), 0);
      // 残差平方和 SSE = Σ(yi - ŷi)²
      const SSE = ys.reduce((sum, y, i) => sum + Math.pow(y - yPred[i], 2), 0);
      // 决定系数 R²
      const R2 = SSR / SST;
      // 均方误差 MSE
      const MSE = SSE / (n - 2);
      // 残差标准差
      const RMSE = Math.sqrt(MSE);

      // 组装结果HTML
      resultDiv.innerHTML = `
        <h2>回归分析结果</h2>
        <p>回归方程：<span class="highlight">y = ${slope.toFixed(4)}x + ${intercept.toFixed(4)}</span></p>
        
        <div class="variance-info">
          <h3>方差分析</h3>
          <p>总平方和 (SST)：${SST.toFixed(4)}</p>
          <p>回归平方和 (SSR)：${SSR.toFixed(4)}</p>
          <p>残差平方和 (SSE)：${SSE.toFixed(4)}</p>
          <p>决定系数 (R²)：${R2.toFixed(4)} (拟合优度，越接近1越好)</p>
          <p>均方误差 (MSE)：${MSE.toFixed(4)}</p>
          <p>残差标准差 (RMSE)：${RMSE.toFixed(4)}</p>
        </div>
      `;

      // 设置canvas基础尺寸（适配响应式）
      canvas.width = canvas.offsetWidth;
      canvas.height = canvas.offsetWidth * 0.5; // 宽高比2:1，适配显示
      
      // 绘制图表
      drawChart(xs, ys, yPred, slope, intercept);
    }

    // 绘制散点图和回归线
    function drawChart(xs, ys, yPred, slope, intercept) {
      const canvas = document.getElementById("chart");
      const ctx = canvas.getContext("2d");

      // 清空画布
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const padding = 30; // 内边距（适配移动端）
      const W = canvas.width;
      const H = canvas.height;

      // 计算数据范围（包含预测值，避免回归线超出范围）
      const allX = [...xs];
      const allY = [...ys, ...yPred];
      const minX = Math.min(...allX);
      const maxX = Math.max(...allX);
      const minY = Math.min(...allY);
      const maxY = Math.max(...allY);

      // 处理极值情况（避免除以0）
      const rangeX = maxX - minX || 1;
      const rangeY = maxY - minY || 1;

      // 计算缩放比例
      const scaleX = (W - padding * 2) / rangeX;
      const scaleY = (H - padding * 2) / rangeY;

      // 绘制散点（原始数据）
      ctx.fillStyle = "white";
      ys.forEach((y, i) => {
        const x = xs[i];
        const plotX = padding + (x - minX) * scaleX;
        const plotY = H - padding - (y - minY) * scaleY;
        ctx.beginPath();
        ctx.arc(plotX, plotY, 4, 0, Math.PI * 2);
        ctx.fill();
      });

      // 绘制回归线
      const lineX1 = minX;
      const lineY1 = slope * lineX1 + intercept;
      const lineX2 = maxX;
      const lineY2 = slope * lineX2 + intercept;

      const px1 = padding + (lineX1 - minX) * scaleX;
      const py1 = H - padding - (lineY1 - minY) * scaleY;
      const px2 = padding + (lineX2 - minX) * scaleX;
      const py2 = H - padding - (lineY2 - minY) * scaleY;

      ctx.strokeStyle = "#4ade80";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(px1, py1);
      ctx.lineTo(px2, py2);
      ctx.stroke();

      // 绘制坐标轴（可选增强）
      ctx.strokeStyle = "#666";
      ctx.lineWidth = 1;
      // X轴
      ctx.beginPath();
      ctx.moveTo(padding, H - padding);
      ctx.lineTo(W - padding, H - padding);
      ctx.stroke();
      // Y轴
      ctx.beginPath();
      ctx.moveTo(padding, padding);
      ctx.lineTo(padding, H - padding);
      ctx.stroke();
    }

    // 窗口大小变化时重新计算（适配响应式）
    window.addEventListener('resize', () => {
      const xs = parseArray(document.getElementById("xValues").value);
      const ys = parseArray(document.getElementById("yValues").value);
      if (xs.length >= 2 && ys.length >= 2 && xs.length === ys.length) {
        computeRegression();
      }
    });
  </script>
</body>
</html>